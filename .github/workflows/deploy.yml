name: CryoProtect v2 Deployment Pipeline

# Workflow triggers
on:
  push:
    branches:
      - main        # Deploy to production when pushing to main
      - staging     # Deploy to staging when pushing to staging
      - dev         # Deploy to development when pushing to dev
    tags:
      - 'v*.*.*'    # Deploy on version tags
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - dev
          - staging
          - production

# Environment variables used across jobs
env:
  PYTHON_VERSION: '3.9'
  NODE_VERSION: '18'

jobs:
  # TESTING PHASE
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        test-group: [unit, integration, security]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Fetch all history for proper versioning
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: Set up Conda
        uses: conda-incubator/setup-miniconda@v2
        with:
          auto-update-conda: true
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Cache Conda packages
        uses: actions/cache@v3
        with:
          path: ~/conda_pkgs_dir
          key: ${{ runner.os }}-conda-${{ hashFiles('environment.yml') }}
          restore-keys: |
            ${{ runner.os }}-conda-
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install Python dependencies
        shell: bash -l {0}
        run: |
          conda env create -f environment.yml
          conda activate cryoprotect
          pip install -r requirements_updated.txt
          pip install pytest pytest-cov pytest-xdist safety bandit flake8
      
      - name: Install Node dependencies
        run: npm ci
      
      # Security scanning
      - name: Run Python vulnerability scan
        if: matrix.test-group == 'security'
        shell: bash -l {0}
        run: |
          conda activate cryoprotect
          safety check -r requirements_updated.txt --output json > safety-report.json || true
          bandit -r . -f json -o bandit-report.json || true
      
      - name: Run Node vulnerability scan
        if: matrix.test-group == 'security'
        run: |
          npm audit --json > npm-audit.json || true
      
      - name: Run code quality checks
        if: matrix.test-group == 'security'
        shell: bash -l {0}
        run: |
          conda activate cryoprotect
          flake8 --max-line-length=120 --output-file=flake8-report.txt || true
      
      # Unit tests
      - name: Run unit tests
        if: matrix.test-group == 'unit'
        shell: bash -l {0}
        run: |
          conda activate cryoprotect
          python -m pytest tests/unit --cov=. --cov-report=xml:coverage-unit.xml --cov-report=html:reports/htmlcov/unit -v
      
      # Integration tests
      - name: Run integration tests
        if: matrix.test-group == 'integration'
        shell: bash -l {0}
        run: |
          conda activate cryoprotect
          python -m pytest tests/integration --cov=. --cov-report=xml:coverage-integration.xml --cov-report=html:reports/htmlcov/integration -v
      
      - name: Upload test results
        uses: actions/upload-artifact@v3
        with:
          name: test-results-${{ matrix.test-group }}
          path: |
            reports/htmlcov/${{ matrix.test-group }}
            coverage-*.xml
            safety-report.json
            npm-audit.json
            bandit-report.json
            flake8-report.txt
          retention-days: 14
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: coverage-*.xml
          flags: ${{ matrix.test-group }}
          fail_ci_if_error: false
          verbose: true
      
      # Notify on test failure
      - name: Notify test failure
        if: failure()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_CHANNEL: ci-alerts
          SLACK_COLOR: danger
          SLACK_TITLE: Test Failure
          SLACK_MESSAGE: "Tests failed in ${{ matrix.test-group }} group! :warning:"
          SLACK_FOOTER: 'CryoProtect v2 CI/CD Pipeline'

  # DOCKER BUILD PHASE
  docker:
    name: Build and Test Docker
    runs-on: ubuntu-latest
    needs: test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Fetch all history for proper versioning
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
      
      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-
      
      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: cryoprotect
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha
      
      - name: Build Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: false
          load: true
          tags: cryoprotect:test
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
      
      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: cryoprotect:test
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'
          exit-code: '1'
          ignore-unfixed: false
      
      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
          
      - name: Generate SBOM for test image
        run: |
          chmod +x ./scripts/generate_sbom.sh
          ./scripts/generate_sbom.sh --format cyclonedx --output sbom-test.json --store-dir ./sbom --version test cryoprotect:test
      
      - name: Upload SBOM as artifact
        uses: actions/upload-artifact@v3
        with:
          name: sbom-test
          path: sbom-test.json
          retention-days: 90
      
      - name: Test Docker image
        run: |
          docker run --name cryoprotect-test -d -p 5000:5000 cryoprotect:test
          sleep 10
          docker exec cryoprotect-test conda run -n cryoprotect python verify_rdkit.py || { echo "RDKit verification failed"; docker logs cryoprotect-test; exit 1; }
          docker exec cryoprotect-test conda run -n cryoprotect curl -s http://localhost:5000/health || { echo "Health check failed"; docker logs cryoprotect-test; exit 1; }
          docker stop cryoprotect-test

  # VERSION DETERMINATION PHASE
  version:
    name: Determine Version
    runs-on: ubuntu-latest
    needs: docker
    outputs:
      version: ${{ steps.set-version.outputs.version }}
      is_release: ${{ steps.set-version.outputs.is_release }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Fetch all history for proper versioning
      
      - name: Set version
        id: set-version
        run: |
          # Check if this is a tag push
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "is_release=true" >> $GITHUB_OUTPUT
          else
            # Use semantic versioning with git describe
            VERSION=$(git describe --tags --always --dirty | sed 's/^v//')
            if [[ ! $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+ ]]; then
              # If no tag exists, use 0.1.0-sha
              SHA=$(git rev-parse --short HEAD)
              VERSION="0.1.0-$SHA"
            fi
            echo "is_release=false" >> $GITHUB_OUTPUT
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
      
      # Create a tag if this is a push to main and not already a tag
      - name: Create version tag
        if: github.ref == 'refs/heads/main' && steps.set-version.outputs.is_release != 'true'
        run: |
          VERSION=${{ steps.set-version.outputs.version }}
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag -a "v$VERSION" -m "Automated tag for version $VERSION"
          git push origin "v$VERSION"

  # DEVELOPMENT DEPLOYMENT PHASE
  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: [docker, version]
    if: github.event_name == 'push' && github.ref == 'refs/heads/dev' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'dev')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          build-args: |
            FLASK_ENV=development
            APP_VERSION=${{ needs.version.outputs.version }}
          tags: |
            ghcr.io/${{ github.repository }}/cryoprotect:dev
            ghcr.io/${{ github.repository }}/cryoprotect:${{ needs.version.outputs.version }}-dev
          cache-from: type=registry,ref=ghcr.io/${{ github.repository }}/cryoprotect:dev-cache
          cache-to: type=registry,ref=ghcr.io/${{ github.repository }}/cryoprotect:dev-cache,mode=max
      
      - name: Deploy to development
        env:
          DEV_SSH_HOST: ${{ secrets.DEV_SSH_HOST }}
          DEV_SSH_USER: ${{ secrets.DEV_SSH_USER }}
          DEV_SSH_KEY: ${{ secrets.DEV_SSH_KEY }}
          APP_VERSION: ${{ needs.version.outputs.version }}
        run: |
          echo "Deploying to development environment..."
          # Write SSH key to file
          mkdir -p ~/.ssh
          echo "$DEV_SSH_KEY" > ~/.ssh/dev_key
          chmod 600 ~/.ssh/dev_key
          
          # Create Docker secrets on dev server
          ssh -i ~/.ssh/dev_key -o StrictHostKeyChecking=no $DEV_SSH_USER@$DEV_SSH_HOST "
            # Create Docker secrets for sensitive values
            echo '${{ secrets.DEV_SUPABASE_URL }}' | docker secret create cryoprotect_supabase_url - || docker secret rm cryoprotect_supabase_url && echo '${{ secrets.DEV_SUPABASE_URL }}' | docker secret create cryoprotect_supabase_url - &&
            echo '${{ secrets.DEV_SUPABASE_KEY }}' | docker secret create cryoprotect_supabase_key - || docker secret rm cryoprotect_supabase_key && echo '${{ secrets.DEV_SUPABASE_KEY }}' | docker secret create cryoprotect_supabase_key - &&
            echo '${{ secrets.DEV_SECRET_KEY }}' | docker secret create cryoprotect_secret_key - || docker secret rm cryoprotect_secret_key && echo '${{ secrets.DEV_SECRET_KEY }}' | docker secret create cryoprotect_secret_key - &&
            
            # Pull the latest image
            docker pull ghcr.io/${{ github.repository }}/cryoprotect:dev &&
            
            # Set non-sensitive environment variables
            export FLASK_ENV=development &&
            export USE_EXTERNAL_SECRETS=true &&
            export APP_VERSION=$APP_VERSION &&
            
            # Deploy with docker-compose
            docker-compose -f docker-compose.dev.yml up -d
          "
      
      - name: Notify deployment status
        if: always()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_CHANNEL: deployments
          SLACK_COLOR: ${{ job.status }}
          SLACK_TITLE: Development Deployment v${{ needs.version.outputs.version }}
          SLACK_MESSAGE: "Deployment to development ${{ job.status }} ! :rocket:"
          SLACK_FOOTER: 'CryoProtect v2 CI/CD Pipeline'
      
      - name: Send email notification
        if: always()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.MAIL_SERVER }}
          server_port: ${{ secrets.MAIL_PORT }}
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: "CryoProtect v2 - Development Deployment ${{ job.status }}"
          body: |
            Development Deployment Status: ${{ job.status }}
            Version: ${{ needs.version.outputs.version }}
            Commit: ${{ github.sha }}
            Deployed by: ${{ github.actor }}
            
            See details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          to: ${{ secrets.DEVOPS_EMAIL }}
          from: CryoProtect CI/CD <${{ secrets.MAIL_USERNAME }}>

  # STAGING DEPLOYMENT PHASE
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [docker, version]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging') || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          build-args: |
            FLASK_ENV=staging
            APP_VERSION=${{ needs.version.outputs.version }}
          tags: |
            ghcr.io/${{ github.repository }}/cryoprotect:staging
            ghcr.io/${{ github.repository }}/cryoprotect:${{ needs.version.outputs.version }}-staging
          cache-from: type=registry,ref=ghcr.io/${{ github.repository }}/cryoprotect:staging-cache
          cache-to: type=registry,ref=ghcr.io/${{ github.repository }}/cryoprotect:staging-cache,mode=max
      
      - name: Deploy to staging
        env:
          STAGING_SSH_HOST: ${{ secrets.STAGING_SSH_HOST }}
          STAGING_SSH_USER: ${{ secrets.STAGING_SSH_USER }}
          STAGING_SSH_KEY: ${{ secrets.STAGING_SSH_KEY }}
          APP_VERSION: ${{ needs.version.outputs.version }}
        run: |
          echo "Deploying to staging environment..."
          # Write SSH key to file
          mkdir -p ~/.ssh
          echo "$STAGING_SSH_KEY" > ~/.ssh/staging_key
          chmod 600 ~/.ssh/staging_key
          
          # Create Docker secrets on staging server
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no $STAGING_SSH_USER@$STAGING_SSH_HOST "
            # Create Docker secrets for sensitive values
            echo '${{ secrets.STAGING_SUPABASE_URL }}' | docker secret create cryoprotect_supabase_url - || docker secret rm cryoprotect_supabase_url && echo '${{ secrets.STAGING_SUPABASE_URL }}' | docker secret create cryoprotect_supabase_url - &&
            echo '${{ secrets.STAGING_SUPABASE_KEY }}' | docker secret create cryoprotect_supabase_key - || docker secret rm cryoprotect_supabase_key && echo '${{ secrets.STAGING_SUPABASE_KEY }}' | docker secret create cryoprotect_supabase_key - &&
            echo '${{ secrets.STAGING_SECRET_KEY }}' | docker secret create cryoprotect_secret_key - || docker secret rm cryoprotect_secret_key && echo '${{ secrets.STAGING_SECRET_KEY }}' | docker secret create cryoprotect_secret_key - &&
            echo '${{ secrets.REDIS_URL }}' | docker secret create cryoprotect_redis_url - || docker secret rm cryoprotect_redis_url && echo '${{ secrets.REDIS_URL }}' | docker secret create cryoprotect_redis_url - &&
            
            # Pull the latest image
            docker pull ghcr.io/${{ github.repository }}/cryoprotect:staging &&
            
            # Set non-sensitive environment variables
            export FLASK_ENV=staging &&
            export USE_EXTERNAL_SECRETS=true &&
            export APP_VERSION=$APP_VERSION &&
            
            # Deploy with docker-compose
            docker-compose up -d
          "
      
      - name: Run post-deployment tests
        env:
          STAGING_SSH_HOST: ${{ secrets.STAGING_SSH_HOST }}
          STAGING_SSH_USER: ${{ secrets.STAGING_SSH_USER }}
          STAGING_SSH_KEY: ${{ secrets.STAGING_SSH_KEY }}
        run: |
          echo "Running post-deployment tests..."
          ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no $STAGING_SSH_USER@$STAGING_SSH_HOST "
            curl -s http://localhost:5000/health || { echo 'Health check failed'; exit 1; }
            curl -s http://localhost:5000/api/v1/status || { echo 'API status check failed'; exit 1; }
          "
      
      - name: Notify deployment status
        if: always()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_CHANNEL: deployments
          SLACK_COLOR: ${{ job.status }}
          SLACK_TITLE: Staging Deployment v${{ needs.version.outputs.version }}
          SLACK_MESSAGE: "Deployment to staging ${{ job.status }} ! :rocket:"
          SLACK_FOOTER: 'CryoProtect v2 CI/CD Pipeline'
      
      - name: Send email notification
        if: always()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.MAIL_SERVER }}
          server_port: ${{ secrets.MAIL_PORT }}
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: "CryoProtect v2 - Staging Deployment ${{ job.status }}"
          body: |
            Staging Deployment Status: ${{ job.status }}
            Version: ${{ needs.version.outputs.version }}
            Commit: ${{ github.sha }}
            Deployed by: ${{ github.actor }}
            
            See details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          to: ${{ secrets.DEVOPS_EMAIL }},${{ secrets.QA_EMAIL }}
          from: CryoProtect CI/CD <${{ secrets.MAIL_USERNAME }}>

  # PRODUCTION DEPLOYMENT PHASE
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-staging, version]
    if: needs.version.outputs.is_release == 'true' || (github.event_name == 'push' && github.ref == 'refs/heads/main') || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Create GitHub Release
        if: needs.version.outputs.is_release == 'true'
        uses: softprops/action-gh-release@v1
        with:
          name: Release v${{ needs.version.outputs.version }}
          tag_name: v${{ needs.version.outputs.version }}
          generate_release_notes: true
          files: |
            LICENSE
            README.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Deploy to production
        env:
          PRODUCTION_SSH_HOST: ${{ secrets.PRODUCTION_SSH_HOST }}
          PRODUCTION_SSH_USER: ${{ secrets.PRODUCTION_SSH_USER }}
          PRODUCTION_SSH_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
          APP_VERSION: ${{ needs.version.outputs.version }}
        run: |
          echo "Deploying version $APP_VERSION to production environment..."
          # Write SSH key to file
          mkdir -p ~/.ssh
          echo "$PRODUCTION_SSH_KEY" > ~/.ssh/production_key
          chmod 600 ~/.ssh/production_key
          
          # Create Docker secrets on production server
          ssh -i ~/.ssh/production_key -o StrictHostKeyChecking=no $PRODUCTION_SSH_USER@$PRODUCTION_SSH_HOST "
            # Create Docker secrets for sensitive values
            echo '${{ secrets.PRODUCTION_SUPABASE_URL }}' | docker secret create cryoprotect_supabase_url - || docker secret rm cryoprotect_supabase_url && echo '${{ secrets.PRODUCTION_SUPABASE_URL }}' | docker secret create cryoprotect_supabase_url - &&
            echo '${{ secrets.PRODUCTION_SUPABASE_KEY }}' | docker secret create cryoprotect_supabase_key - || docker secret rm cryoprotect_supabase_key && echo '${{ secrets.PRODUCTION_SUPABASE_KEY }}' | docker secret create cryoprotect_supabase_key - &&
            echo '${{ secrets.PRODUCTION_SECRET_KEY }}' | docker secret create cryoprotect_secret_key - || docker secret rm cryoprotect_secret_key && echo '${{ secrets.PRODUCTION_SECRET_KEY }}' | docker secret create cryoprotect_secret_key - &&
            echo '${{ secrets.REDIS_URL }}' | docker secret create cryoprotect_redis_url - || docker secret rm cryoprotect_redis_url && echo '${{ secrets.REDIS_URL }}' | docker secret create cryoprotect_redis_url - &&
            
            # Pull and tag the image
            docker pull ghcr.io/${{ github.repository }}/cryoprotect:$APP_VERSION-staging &&
            docker tag ghcr.io/${{ github.repository }}/cryoprotect:$APP_VERSION-staging ghcr.io/${{ github.repository }}/cryoprotect:production &&
            
            # Set non-sensitive environment variables
            export FLASK_ENV=production &&
            export USE_EXTERNAL_SECRETS=true &&
            export APP_VERSION=$APP_VERSION &&
            
            # Deploy with docker-compose
            docker-compose up -d
          "
      
      - name: Notify deployment status
        if: always()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_CHANNEL: deployments
          SLACK_COLOR: ${{ job.status }}
          SLACK_TITLE: Production Deployment v${{ needs.version.outputs.version }}
          SLACK_MESSAGE: "Deployment to production ${{ job.status }} ! :rocket:"
          SLACK_FOOTER: 'CryoProtect v2 CI/CD Pipeline'
      
      - name: Send email notification
        if: always()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.MAIL_SERVER }}
          server_port: ${{ secrets.MAIL_PORT }}
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: "CryoProtect v2 - Production Deployment ${{ job.status }}"
          body: |
            Production Deployment Status: ${{ job.status }}
            Version: ${{ needs.version.outputs.version }}
            Commit: ${{ github.sha }}
            Deployed by: ${{ github.actor }}
            
            See details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          to: ${{ secrets.DEVOPS_EMAIL }},${{ secrets.QA_EMAIL }},${{ secrets.PRODUCT_EMAIL }}
          from: CryoProtect CI/CD <${{ secrets.MAIL_USERNAME }}>

  # BLUE/GREEN DEPLOYMENT PHASE
  blue-green-deployment:
    name: Blue/Green Deployment
    runs-on: ubuntu-latest
    needs: [deploy-production, version]
    if: needs.version.outputs.is_release == 'true' || (github.event_name == 'push' && github.ref == 'refs/heads/main') || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Generate SBOM for production image
        run: |
          chmod +x ./scripts/generate_sbom.sh
          mkdir -p ./sbom
          
          # Generate SBOM for staging image
          ./scripts/generate_sbom.sh \
            --format cyclonedx \
            --output sbom-staging.json \
            --store-dir ./sbom \
            --version ${{ needs.version.outputs.version }}-staging \
            ghcr.io/${{ github.repository }}/cryoprotect:${{ needs.version.outputs.version }}-staging
          
          # Generate SBOM for production image
          ./scripts/generate_sbom.sh \
            --format cyclonedx \
            --output sbom-production.json \
            --store-dir ./sbom \
            --version ${{ needs.version.outputs.version }} \
            ghcr.io/${{ github.repository }}/cryoprotect:production
      
      - name: Upload SBOM artifacts
        uses: actions/upload-artifact@v3
        with:
          name: sbom-${{ needs.version.outputs.version }}
          path: |
            sbom-staging.json
            sbom-production.json
            ./sbom/*.json
          retention-days: 90
      
      - name: Store SBOM in production server
        env:
          PRODUCTION_SSH_HOST: ${{ secrets.PRODUCTION_SSH_HOST }}
          PRODUCTION_SSH_USER: ${{ secrets.PRODUCTION_SSH_USER }}
          PRODUCTION_SSH_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
          APP_VERSION: ${{ needs.version.outputs.version }}
        run: |
          # Write SSH key to file
          mkdir -p ~/.ssh
          echo "$PRODUCTION_SSH_KEY" > ~/.ssh/production_key
          chmod 600 ~/.ssh/production_key
          
          # Create SBOM directory on production server
          ssh -i ~/.ssh/production_key -o StrictHostKeyChecking=no $PRODUCTION_SSH_USER@$PRODUCTION_SSH_HOST "
            mkdir -p /var/log/cryoprotect/sbom
          "
          
          # Copy SBOM files to production server
          scp -i ~/.ssh/production_key -o StrictHostKeyChecking=no \
            ./sbom/*.json \
            $PRODUCTION_SSH_USER@$PRODUCTION_SSH_HOST:/var/log/cryoprotect/sbom/
      
      - name: Prepare deployment
        id: prepare
        run: |
          # Generate a unique deployment ID
          DEPLOY_ID=$(date -u +"%Y%m%d%H%M%S")
          echo "deploy_id=$DEPLOY_ID" >> $GITHUB_OUTPUT
          echo "Deployment ID: $DEPLOY_ID"
      
      - name: Deploy to inactive environment
        env:
          PRODUCTION_SSH_HOST: ${{ secrets.PRODUCTION_SSH_HOST }}
          PRODUCTION_SSH_USER: ${{ secrets.PRODUCTION_SSH_USER }}
          PRODUCTION_SSH_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
          APP_VERSION: ${{ needs.version.outputs.version }}
          DEPLOY_ID: ${{ steps.prepare.outputs.deploy_id }}
        run: |
          echo "Deploying version $APP_VERSION using blue/green deployment (ID: $DEPLOY_ID)..."
          # Write SSH key to file
          mkdir -p ~/.ssh
          echo "$PRODUCTION_SSH_KEY" > ~/.ssh/production_key
          chmod 600 ~/.ssh/production_key
          
          # Determine active environment and deploy to inactive environment
          ssh -i ~/.ssh/production_key -o StrictHostKeyChecking=no $PRODUCTION_SSH_USER@$PRODUCTION_SSH_HOST "
            # Create Docker secrets with unique names for this deployment
            echo '${{ secrets.PRODUCTION_SUPABASE_URL }}' | docker secret create cryoprotect_supabase_url_${DEPLOY_ID} - || true
            echo '${{ secrets.PRODUCTION_SUPABASE_KEY }}' | docker secret create cryoprotect_supabase_key_${DEPLOY_ID} - || true
            echo '${{ secrets.PRODUCTION_SECRET_KEY }}' | docker secret create cryoprotect_secret_key_${DEPLOY_ID} - || true
            echo '${{ secrets.REDIS_URL }}' | docker secret create cryoprotect_redis_url_${DEPLOY_ID} - || true
            
            # Create secret rotation timestamp
            date +%s > /tmp/secret_rotation_timestamp
            docker secret create secret_rotation_timestamp_${DEPLOY_ID} /tmp/secret_rotation_timestamp
            rm /tmp/secret_rotation_timestamp
            
            # Set environment variables for deployment
            export DEPLOY_ID=${DEPLOY_ID}
            export SUPABASE_URL_SECRET=cryoprotect_supabase_url_${DEPLOY_ID}
            export SUPABASE_KEY_SECRET=cryoprotect_supabase_key_${DEPLOY_ID}
            export SECRET_KEY_SECRET=cryoprotect_secret_key_${DEPLOY_ID}
            export REDIS_URL_SECRET=cryoprotect_redis_url_${DEPLOY_ID}
            export SECRET_ROTATION_TIMESTAMP=secret_rotation_timestamp_${DEPLOY_ID}
            export FLASK_ENV=production
            export USE_EXTERNAL_SECRETS=true
            
            # Pull the latest image
            docker pull ghcr.io/${{ github.repository }}/cryoprotect:$APP_VERSION-staging
            
            # Check which environment is currently active
            if grep -q 'proxy_pass http://blue' /etc/nginx/conf.d/active.conf; then
              echo 'Blue environment is active, deploying to green...'
              export GREEN_VERSION=$APP_VERSION
              ./scripts/deploy-green.sh --version $APP_VERSION
            else
              echo 'Green environment is active, deploying to blue...'
              export BLUE_VERSION=$APP_VERSION
              ./scripts/deploy-blue.sh --version $APP_VERSION
            fi
          "
      
      - name: Run health checks
        env:
          PRODUCTION_SSH_HOST: ${{ secrets.PRODUCTION_SSH_HOST }}
          PRODUCTION_SSH_USER: ${{ secrets.PRODUCTION_SSH_USER }}
          PRODUCTION_SSH_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
        run: |
          echo "Running health checks..."
          ssh -i ~/.ssh/production_key -o StrictHostKeyChecking=no $PRODUCTION_SSH_USER@$PRODUCTION_SSH_HOST "
            # Run comprehensive health checks
            ./scripts/check-health.sh --verbose
            
            # Verify database connectivity
            if grep -q 'proxy_pass http://blue' /etc/nginx/conf.d/active.conf; then
              docker exec \$(docker ps --filter 'name=cryoprotect-green' --quiet) /opt/conda/envs/cryoprotect/bin/python -c 'from database.utils.health_check import check_database_connection; print(check_database_connection())'
            else
              docker exec \$(docker ps --filter 'name=cryoprotect-blue' --quiet) /opt/conda/envs/cryoprotect/bin/python -c 'from database.utils.health_check import check_database_connection; print(check_database_connection())'
            fi
            
            # Verify API endpoints
            if grep -q 'proxy_pass http://blue' /etc/nginx/conf.d/active.conf; then
              CONTAINER=\$(docker ps --filter 'name=cryoprotect-green' --quiet)
            else
              CONTAINER=\$(docker ps --filter 'name=cryoprotect-blue' --quiet)
            fi
            
            # Check critical API endpoints
            docker exec \$CONTAINER curl -s http://localhost:5000/health/readiness
            docker exec \$CONTAINER curl -s http://localhost:5000/health/liveness
            docker exec \$CONTAINER curl -s http://localhost:5000/api/v1/status
          "
      
      - name: Switch traffic to new environment
        env:
          PRODUCTION_SSH_HOST: ${{ secrets.PRODUCTION_SSH_HOST }}
          PRODUCTION_SSH_USER: ${{ secrets.PRODUCTION_SSH_USER }}
          PRODUCTION_SSH_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
        run: |
          echo "Switching traffic to new environment..."
          ssh -i ~/.ssh/production_key -o StrictHostKeyChecking=no $PRODUCTION_SSH_USER@$PRODUCTION_SSH_HOST "
            # Check which environment was just deployed to
            if grep -q 'proxy_pass http://blue' /etc/nginx/conf.d/active.conf; then
              echo 'Switching traffic to green environment...'
              ./scripts/switch-to-green.sh
              
              # Verify the switch was successful
              if ! grep -q 'proxy_pass http://green' /etc/nginx/conf.d/active.conf; then
                echo 'ERROR: Traffic switch to green environment failed!'
                exit 1
              fi
            else
              echo 'Switching traffic to blue environment...'
              ./scripts/switch-to-blue.sh
              
              # Verify the switch was successful
              if ! grep -q 'proxy_pass http://blue' /etc/nginx/conf.d/active.conf; then
                echo 'ERROR: Traffic switch to blue environment failed!'
                exit 1
              fi
            fi
            
            # Verify the application is responding after the switch
            curl -f http://localhost/health || {
              echo 'ERROR: Application health check failed after traffic switch!'
              exit 1
            }
          "
      
      - name: Clean up old secrets
        if: success()
        env:
          PRODUCTION_SSH_HOST: ${{ secrets.PRODUCTION_SSH_HOST }}
          PRODUCTION_SSH_USER: ${{ secrets.PRODUCTION_SSH_USER }}
          PRODUCTION_SSH_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
          DEPLOY_ID: ${{ steps.prepare.outputs.deploy_id }}
        run: |
          echo "Cleaning up old secrets..."
          ssh -i ~/.ssh/production_key -o StrictHostKeyChecking=no $PRODUCTION_SSH_USER@$PRODUCTION_SSH_HOST "
            # List all secrets
            SECRETS=\$(docker secret ls --format '{{.Name}}' | grep -E 'cryoprotect_(supabase_url|supabase_key|secret_key|redis_url)_[0-9]+' || true)
            
            # Get current secrets
            CURRENT_SECRETS=\"cryoprotect_supabase_url_${DEPLOY_ID} cryoprotect_supabase_key_${DEPLOY_ID} cryoprotect_secret_key_${DEPLOY_ID} cryoprotect_redis_url_${DEPLOY_ID} secret_rotation_timestamp_${DEPLOY_ID}\"
            
            # Remove old secrets (keep the current ones)
            for SECRET in \$SECRETS; do
              if ! echo \"\$CURRENT_SECRETS\" | grep -q \"\$SECRET\"; then
                echo \"Removing old secret: \$SECRET\"
                docker service update --secret-rm \$SECRET cryoprotect-blue cryoprotect-green 2>/dev/null || true
                docker secret rm \$SECRET 2>/dev/null || true
              fi
            done
          "
      
      - name: Create deployment record
        env:
          PRODUCTION_SSH_HOST: ${{ secrets.PRODUCTION_SSH_HOST }}
          PRODUCTION_SSH_USER: ${{ secrets.PRODUCTION_SSH_USER }}
          PRODUCTION_SSH_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
          APP_VERSION: ${{ needs.version.outputs.version }}
          DEPLOY_ID: ${{ steps.prepare.outputs.deploy_id }}
        run: |
          echo "Creating deployment record..."
          ssh -i ~/.ssh/production_key -o StrictHostKeyChecking=no $PRODUCTION_SSH_USER@$PRODUCTION_SSH_HOST "
            # Create deployment record
            mkdir -p /var/log/cryoprotect/deployments
            cat > /var/log/cryoprotect/deployments/deployment-${DEPLOY_ID}.json << EOF
            {
              \"deploy_id\": \"${DEPLOY_ID}\",
              \"version\": \"${APP_VERSION}\",
              \"timestamp\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\",
              \"deployed_by\": \"${{ github.actor }}\",
              \"commit\": \"${{ github.sha }}\",
              \"workflow_run\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
            }
            EOF
            
            # Update latest deployment symlink
            ln -sf /var/log/cryoprotect/deployments/deployment-${DEPLOY_ID}.json /var/log/cryoprotect/deployments/latest.json
          "
      
      - name: Notify deployment status
        if: always()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_CHANNEL: deployments
          SLACK_COLOR: ${{ job.status }}
          SLACK_TITLE: Blue/Green Deployment v${{ needs.version.outputs.version }}
          SLACK_MESSAGE: "Blue/Green deployment ${{ job.status }} ! :rocket:"
          SLACK_FOOTER: 'CryoProtect v2 CI/CD Pipeline'
      
      - name: Send deployment notification email
        if: always()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.MAIL_SERVER }}
          server_port: ${{ secrets.MAIL_PORT }}
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: "CryoProtect v2 - Blue/Green Deployment ${{ job.status }}"
          body: |
            Blue/Green Deployment Status: ${{ job.status }}
            Version: ${{ needs.version.outputs.version }}
            Deployment ID: ${{ steps.prepare.outputs.deploy_id }}
            Commit: ${{ github.sha }}
            Deployed by: ${{ github.actor }}
            
            See details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          to: ${{ secrets.DEVOPS_EMAIL }},${{ secrets.QA_EMAIL }},${{ secrets.PRODUCT_EMAIL }}
          from: CryoProtect CI/CD <${{ secrets.MAIL_USERNAME }}>
