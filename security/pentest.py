#!/usr/bin/env python3
"""
CryoProtect v2 Security Penetration Testing Script

This script performs comprehensive penetration testing and validation of security controls
implemented as part of the security audit remediation plan. It tests:

1. CSRF Protection
2. Security Headers
3. Cookie Security
4. Encryption at Rest
5. Vulnerability Scanning Integration

Usage:
    python pentest.py [--url URL] [--report-file REPORT_FILE] [--verbose]

Options:
    --url URL                 Base URL of the application to test (default: http://localhost:5000)
    --report-file REPORT_FILE Output file for the test report (default: pentest_report_YYYYMMDD_HHMMSS.json)
    --verbose                 Enable verbose output
"""

import argparse
import base64
import json
import os
import re
import requests
import subprocess
import sys
import time
from datetime import datetime
from urllib.parse import urljoin
import logging
import hashlib
import random
import string

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('security_pentest')

# Constants
DEFAULT_URL = "http://localhost:5000"
DEFAULT_REPORT_FILE = f"pentest_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
TEST_USERNAME = "pentest_user@example.com"
TEST_PASSWORD = "SecureP@ssw0rd123!"
TEST_DATA = {
    "name": "Penetration Test Data",
    "description": "This is test data for security penetration testing",
    "sensitive_field": "SENSITIVE_DATA_FOR_ENCRYPTION_TEST"
}

class SecurityPenTester:
    """Main class for security penetration testing."""
    
    def __init__(self, base_url=DEFAULT_URL, report_file=DEFAULT_REPORT_FILE, verbose=False):
        """Initialize the penetration tester."""
        self.base_url = base_url
        self.report_file = report_file
        self.verbose = verbose
        self.session = requests.Session()
        self.results = {
            "timestamp": datetime.now().isoformat(),
            "base_url": base_url,
            "tests": {},
            "summary": {
                "passed": 0,
                "failed": 0,
                "warnings": 0,
                "total": 0
            }
        }
        
        # Set up logging level
        if verbose:
            logger.setLevel(logging.DEBUG)
        
        logger.info(f"Initializing security penetration testing against {base_url}")
        logger.info(f"Results will be saved to {report_file}")
    
    def log_request(self, method, url, **kwargs):
        """Log request details if verbose mode is enabled."""
        if self.verbose:
            logger.debug(f"Request: {method} {url}")
            if 'headers' in kwargs:
                logger.debug(f"Headers: {json.dumps(kwargs['headers'], indent=2)}")
            if 'data' in kwargs:
                logger.debug(f"Data: {kwargs['data']}")
            if 'json' in kwargs:
                logger.debug(f"JSON: {json.dumps(kwargs['json'], indent=2)}")
    
    def log_response(self, response):
        """Log response details if verbose mode is enabled."""
        if self.verbose:
            logger.debug(f"Response: {response.status_code}")
            logger.debug(f"Headers: {json.dumps(dict(response.headers), indent=2)}")
            try:
                logger.debug(f"Content: {json.dumps(response.json(), indent=2)}")
            except:
                if len(response.content) > 1000:
                    logger.debug(f"Content: {response.content[:1000]}... (truncated)")
                else:
                    logger.debug(f"Content: {response.content}")
    
    def request(self, method, endpoint, **kwargs):
        """Make an HTTP request and log details if verbose."""
        url = urljoin(self.base_url, endpoint)
        self.log_request(method, url, **kwargs)
        
        try:
            response = self.session.request(method, url, **kwargs)
            self.log_response(response)
            return response
        except requests.RequestException as e:
            logger.error(f"Request error: {str(e)}")
            return None
    
    def record_result(self, test_name, category, passed, details=None, severity="high"):
        """Record a test result."""
        if details is None:
            details = {}
        
        self.results["tests"].setdefault(category, {})[test_name] = {
            "passed": passed,
            "severity": severity,
            "details": details,
            "timestamp": datetime.now().isoformat()
        }
        
        # Update summary
        self.results["summary"]["total"] += 1
        if passed:
            self.results["summary"]["passed"] += 1
        else:
            self.results["summary"]["failed"] += 1
        
        # Log result
        status = "PASSED" if passed else "FAILED"
        logger.info(f"Test {test_name} {status} - {category} - {severity} severity")
    
    def authenticate(self):
        """Authenticate with the application and return auth tokens."""
        logger.info("Authenticating with the application...")
        
        # Try to register a test user first
        register_data = {
            "email": TEST_USERNAME,
            "password": TEST_PASSWORD,
            "name": "Penetration Tester"
        }
        
        try:
            register_response = self.request("POST", "/auth/register", json=register_data)
            if register_response and register_response.status_code in (200, 201):
                logger.info("Test user registered successfully")
            else:
                logger.info("User may already exist, proceeding to login")
        except Exception as e:
            logger.warning(f"Error during registration: {str(e)}")
        
        # Login with the test user
        login_data = {
            "email": TEST_USERNAME,
            "password": TEST_PASSWORD
        }
        
        try:
            login_response = self.request("POST", "/auth/login", json=login_data)
            
            if not login_response or login_response.status_code != 200:
                logger.error("Authentication failed")
                return None
            
            # Extract auth tokens from response
            auth_data = login_response.json()
            
            # Store auth tokens in session for subsequent requests
            if 'access_token' in auth_data:
                self.session.headers.update({
                    'Authorization': f"Bearer {auth_data['access_token']}"
                })
            
            # Check for CSRF token in cookies or response
            csrf_token = None
            if 'csrf_token' in self.session.cookies:
                csrf_token = self.session.cookies['csrf_token']
            elif 'csrf_token' in auth_data:
                csrf_token = auth_data['csrf_token']
            
            if csrf_token:
                self.session.headers.update({
                    'X-CSRF-Token': csrf_token
                })
            
            logger.info("Authentication successful")
            return auth_data
        except Exception as e:
            logger.error(f"Authentication error: {str(e)}")
            return None
    
    def test_csrf_protection(self):
        """Test CSRF protection implementation."""
        logger.info("Testing CSRF protection...")
        category = "CSRF Protection"
        
        # Test 1: Verify CSRF token is provided
        response = self.request("GET", "/api/v1/csrf-token")
        csrf_token_provided = False
        csrf_token = None
        
        if response and response.status_code == 200:
            data = response.json()
            if 'csrf_token' in data:
                csrf_token = data['csrf_token']
                csrf_token_provided = True
        
        self.record_result(
            "csrf_token_endpoint", 
            category, 
            csrf_token_provided,
            {"response": response.json() if response else None}
        )
        
        # Test 2: Attempt state-changing request without CSRF token
        if csrf_token:
            # Save the current CSRF token
            current_csrf = self.session.headers.get('X-CSRF-Token')
            
            # Remove CSRF token from headers
            if 'X-CSRF-Token' in self.session.headers:
                del self.session.headers['X-CSRF-Token']
            
            # Attempt a state-changing request (POST)
            test_data = {"test_field": "test_value"}
            response = self.request("POST", "/api/v1/test/csrf", json=test_data)
            
            # Request should be rejected with 403 Forbidden
            csrf_protection_working = False
            if response and response.status_code == 403:
                csrf_protection_working = True
            
            self.record_result(
                "csrf_protection_enforced", 
                category, 
                csrf_protection_working,
                {
                    "status_code": response.status_code if response else None,
                    "expected_status_code": 403
                }
            )
            
            # Restore CSRF token
            if current_csrf:
                self.session.headers['X-CSRF-Token'] = current_csrf
        else:
            self.record_result(
                "csrf_protection_enforced", 
                category, 
                False,
                {"error": "Could not obtain CSRF token for testing"}
            )
        
        # Test 3: Verify state-changing request with valid CSRF token
        if csrf_token:
            # Ensure CSRF token is in headers
            self.session.headers['X-CSRF-Token'] = csrf_token
            
            # Attempt a state-changing request (POST)
            test_data = {"test_field": "test_value"}
            response = self.request("POST", "/api/v1/test/csrf", json=test_data)
            
            # Request should succeed (not 403)
            valid_csrf_accepted = False
            if response and response.status_code != 403:
                valid_csrf_accepted = True
            
            self.record_result(
                "valid_csrf_accepted", 
                category, 
                valid_csrf_accepted,
                {
                    "status_code": response.status_code if response else None,
                    "expected_status_code": "not 403"
                }
            )
    
    def test_security_headers(self):
        """Test security headers implementation."""
        logger.info("Testing security headers...")
        category = "Security Headers"
        
        # Make a request to the application
        response = self.request("GET", "/")
        
        if not response:
            self.record_result(
                "security_headers_present", 
                category, 
                False,
                {"error": "Could not connect to application"}
            )
            return
        
        # Required security headers
        required_headers = {
            "Content-Security-Policy": None,
            "Strict-Transport-Security": None,
            "X-Content-Type-Options": "nosniff",
            "X-Frame-Options": None,
            "X-XSS-Protection": None,
            "Referrer-Policy": None,
            "Permissions-Policy": None
        }
        
        # Check for presence of required headers
        headers_present = {}
        missing_headers = []
        
        for header, expected_value in required_headers.items():
            if header.lower() in [h.lower() for h in response.headers]:
                # Get the actual header name with correct case
                actual_header = next(h for h in response.headers if h.lower() == header.lower())
                value = response.headers[actual_header]
                headers_present[header] = value
                
                # Check if the value matches expected value (if specified)
                if expected_value and expected_value not in value:
                    missing_headers.append(f"{header} (invalid value: {value})")
            else:
                missing_headers.append(header)
        
        # Record results
        all_headers_present = len(missing_headers) == 0
        self.record_result(
            "security_headers_present", 
            category, 
            all_headers_present,
            {
                "headers_present": headers_present,
                "missing_headers": missing_headers
            }
        )
        
        # Test Content-Security-Policy specifically
        if "Content-Security-Policy" in headers_present:
            csp = headers_present["Content-Security-Policy"]
            
            # Check for unsafe-inline in script-src (should be avoided)
            unsafe_inline_warning = "'unsafe-inline'" in csp and "script-src" in csp
            
            self.record_result(
                "content_security_policy_quality", 
                category, 
                not unsafe_inline_warning,
                {
                    "csp": csp,
                    "warning": "CSP uses unsafe-inline for scripts" if unsafe_inline_warning else None
                },
                severity="medium"
            )
    
    def test_cookie_security(self):
        """Test cookie security implementation."""
        logger.info("Testing cookie security...")
        category = "Cookie Security"
        
        # Authenticate to get session cookies
        auth_data = self.authenticate()
        
        if not auth_data:
            self.record_result(
                "secure_cookies", 
                category, 
                False,
                {"error": "Could not authenticate to test cookies"}
            )
            return
        
        # Check for session cookie
        session_cookie = None
        for cookie in self.session.cookies:
            if cookie.name == 'session':
                session_cookie = cookie
                break
        
        if not session_cookie:
            self.record_result(
                "secure_cookies", 
                category, 
                False,
                {"error": "No session cookie found"}
            )
            return
        
        # Check cookie attributes
        secure = session_cookie.secure
        httponly = session_cookie.has_nonstandard_attr('HttpOnly')
        samesite = session_cookie.get_nonstandard_attr('SameSite')
        
        # Record results
        all_attributes_secure = secure and httponly and samesite in ('Lax', 'Strict')
        self.record_result(
            "secure_cookies", 
            category, 
            all_attributes_secure,
            {
                "secure": secure,
                "httponly": httponly,
                "samesite": samesite,
                "expected": {
                    "secure": True,
                    "httponly": True,
                    "samesite": "Lax or Strict"
                }
            }
        )
        
        # Test session rotation on privilege change
        # This would require admin access to test properly, so we'll simulate by checking if
        # the session cookie changes after a profile update
        
        # Get current session cookie value
        original_session_value = session_cookie.value
        
        # Update user profile (which might trigger session rotation)
        profile_data = {
            "name": f"Penetration Tester {datetime.now().strftime('%H%M%S')}"
        }
        
        response = self.request("POST", "/auth/update-profile", json=profile_data)
        
        # Check if session cookie was rotated
        new_session_cookie = None
        for cookie in self.session.cookies:
            if cookie.name == 'session':
                new_session_cookie = cookie
                break
        
        session_rotated = False
        if new_session_cookie and new_session_cookie.value != original_session_value:
            session_rotated = True
        
        self.record_result(
            "session_rotation", 
            category, 
            session_rotated,
            {
                "session_changed": session_rotated,
                "response_status": response.status_code if response else None
            },
            severity="medium"
        )
    
    def test_encryption_at_rest(self):
        """Test encryption at rest implementation."""
        logger.info("Testing encryption at rest...")
        category = "Encryption at Rest"
        
        # We'll test this by creating data with sensitive fields and then
        # checking if the data is stored encrypted in the database
        
        # 1. Create test data with sensitive information
        test_data = {
            "name": f"Encryption Test {datetime.now().strftime('%H%M%S')}",
            "sensitive_data": f"SENSITIVE_{hashlib.md5(os.urandom(32)).hexdigest()}"
        }
        
        # Endpoint that stores sensitive data (this will vary by application)
        response = self.request("POST", "/api/v1/test/encryption", json=test_data)
        
        if not response or response.status_code not in (200, 201):
            self.record_result(
                "encryption_at_rest", 
                category, 
                False,
                {
                    "error": "Could not create test data",
                    "status_code": response.status_code if response else None
                }
            )
            return
        
        # Get the created data ID
        data_id = None
        try:
            data_id = response.json().get('id')
        except:
            pass
        
        if not data_id:
            self.record_result(
                "encryption_at_rest", 
                category, 
                False,
                {"error": "Could not get ID of created test data"}
            )
            return
        
        # 2. Retrieve the data through the API
        response = self.request("GET", f"/api/v1/test/encryption/{data_id}")
        
        if not response or response.status_code != 200:
            self.record_result(
                "encryption_at_rest", 
                category, 
                False,
                {
                    "error": "Could not retrieve test data",
                    "status_code": response.status_code if response else None
                }
            )
            return
        
        # 3. Verify the sensitive data is returned correctly (decrypted)
        retrieved_data = response.json()
        sensitive_data_correct = retrieved_data.get('sensitive_data') == test_data['sensitive_data']
        
        self.record_result(
            "encryption_decryption", 
            category, 
            sensitive_data_correct,
            {
                "original_data": test_data['sensitive_data'],
                "retrieved_data": retrieved_data.get('sensitive_data')
            }
        )
        
        # 4. Check if the data is stored encrypted in the database
        # This is challenging to test directly in a black-box test
        # We'll check if the API provides a way to verify encryption status
        
        response = self.request("GET", f"/api/v1/test/encryption/{data_id}/metadata")
        
        encryption_verified = False
        if response and response.status_code == 200:
            metadata = response.json()
            if 'encrypted' in metadata:
                encryption_verified = metadata['encrypted']
        
        self.record_result(
            "encryption_at_rest", 
            category, 
            encryption_verified,
            {
                "metadata": metadata if response and response.status_code == 200 else None,
                "note": "Limited verification possible in black-box testing"
            }
        )
    
    def test_vulnerability_scanning(self):
        """Test vulnerability scanning integration."""
        logger.info("Testing vulnerability scanning integration...")
        category = "Vulnerability Scanning"
        
        # This is primarily a CI/CD and operational test, not an API test
        # We'll check if the vulnerability scanning scripts exist and are executable
        
        scan_scripts = [
            "security/scan_python_bandit.py",
            "security/scan_python_safety.py",
            "security/scan_js_eslint.js"
        ]
        
        scripts_exist = []
        scripts_missing = []
        
        for script in scan_scripts:
            if os.path.exists(script) and os.access(script, os.X_OK):
                scripts_exist.append(script)
            else:
                scripts_missing.append(script)
        
        all_scripts_exist = len(scripts_missing) == 0
        self.record_result(
            "vulnerability_scan_scripts", 
            category, 
            all_scripts_exist,
            {
                "scripts_exist": scripts_exist,
                "scripts_missing": scripts_missing
            }
        )
        
        # Try running one of the scripts to verify it works
        if "security/scan_python_bandit.py" in scripts_exist:
            try:
                # Run with minimal scope and output to avoid disruption
                result = subprocess.run(
                    ["python", "security/scan_python_bandit.py", "--path", "security", "--format", "json"],
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                
                script_executable = result.returncode == 0
                self.record_result(
                    "vulnerability_scan_execution", 
                    category, 
                    script_executable,
                    {
                        "returncode": result.returncode,
                        "stdout": result.stdout[:500] + "..." if len(result.stdout) > 500 else result.stdout,
                        "stderr": result.stderr[:500] + "..." if len(result.stderr) > 500 else result.stderr
                    }
                )
            except Exception as e:
                self.record_result(
                    "vulnerability_scan_execution", 
                    category, 
                    False,
                    {"error": str(e)}
                )
        else:
            self.record_result(
                "vulnerability_scan_execution", 
                category, 
                False,
                {"error": "Bandit scan script not found or not executable"}
            )
    
    def run_all_tests(self):
        """Run all security penetration tests."""
        logger.info("Starting comprehensive security penetration testing...")
        
        try:
            # Test CSRF protection
            self.test_csrf_protection()
            
            # Test security headers
            self.test_security_headers()
            
            # Test cookie security
            self.test_cookie_security()
            
            # Test encryption at rest
            self.test_encryption_at_rest()
            
            # Test vulnerability scanning
            self.test_vulnerability_scanning()
            
            # Generate final report
            self.generate_report()
            
            logger.info("Security penetration testing completed.")
            return self.results
        except Exception as e:
            logger.error(f"Error during penetration testing: {str(e)}", exc_info=True)
            self.results["error"] = str(e)
            self.generate_report()
            return self.results
    
    def generate_report(self):
        """Generate the final penetration testing report."""
        logger.info(f"Generating penetration testing report: {self.report_file}")
        
        # Calculate overall pass rate
        total = self.results["summary"]["total"]
        passed = self.results["summary"]["passed"]
        pass_rate = (passed / total) * 100 if total > 0 else 0
        
        self.results["summary"]["pass_rate"] = f"{pass_rate:.2f}%"
        self.results["summary"]["timestamp"] = datetime.now().isoformat()
        
        # Add overall status
        if pass_rate == 100:
            self.results["summary"]["status"] = "PASSED"
        elif pass_rate >= 80:
            self.results["summary"]["status"] = "PARTIAL"
        else:
            self.results["summary"]["status"] = "FAILED"
        
        # Write report to file
        with open(self.report_file, 'w') as f:
            json.dump(self.results, f, indent=2)
        
        logger.info(f"Report generated: {self.report_file}")
        logger.info(f"Summary: {self.results['summary']['passed']}/{self.results['summary']['total']} tests passed ({self.results['summary']['pass_rate']})")
        logger.info(f"Overall status: {self.results['summary']['status']}")
        
        return self.results


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="Security penetration testing script")
    parser.add_argument("--url", default=DEFAULT_URL, help=f"Base URL of the application to test (default: {DEFAULT_URL})")
    parser.add_argument("--report-file", default=DEFAULT_REPORT_FILE, help=f"Output file for the test report (default: {DEFAULT_REPORT_FILE})")
    parser.add_argument("--verbose", action="store_true", help="Enable verbose output")
    return parser.parse_args()


def main():
    """Main function."""
    args = parse_args()
    
    # Create and run the penetration tester
    tester = SecurityPenTester(
        base_url=args.url,
        report_file=args.report_file,
        verbose=args.verbose
    )
    
    results = tester.run_all_tests()
    
    # Exit with status code based on test results
    if results["summary"]["status"] == "PASSED":
        sys.exit(0)
    else:
        sys.exit(1)


if __name__ == "__main__":
    main()