#!/usr/bin/env python3
"""
CryoProtect v2 Security Penetration Test Runner

This script runs the security penetration tests and generates a comprehensive report
validating all security controls implemented as part of the remediation plan.

Usage:
    python run_pentest.py [--url URL] [--output-dir OUTPUT_DIR] [--html] [--pdf]

Options:
    --url URL                 Base URL of the application to test (default: http://localhost:5000)
    --output-dir OUTPUT_DIR   Directory to save reports (default: reports/security)
    --html                    Generate HTML report in addition to JSON
    --pdf                     Generate PDF report in addition to JSON
"""

import argparse
import json
import os
import subprocess
import sys
import time
from datetime import datetime
import logging
import shutil
from pathlib import Path

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('pentest_runner')

# Constants
DEFAULT_URL = "http://localhost:5000"
DEFAULT_OUTPUT_DIR = "reports/security"


def setup_output_directory(output_dir):
    """Create output directory if it doesn't exist."""
    os.makedirs(output_dir, exist_ok=True)
    logger.info(f"Output directory: {output_dir}")


def run_penetration_tests(url, output_dir):
    """Run the penetration tests and return the path to the report file."""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    report_file = os.path.join(output_dir, f"pentest_report_{timestamp}.json")
    
    logger.info(f"Running penetration tests against {url}")
    logger.info(f"Report will be saved to {report_file}")
    
    try:
        # Run the penetration test script
        result = subprocess.run(
            [
                sys.executable,
                "security/pentest.py",
                "--url", url,
                "--report-file", report_file,
                "--verbose"
            ],
            capture_output=True,
            text=True,
            check=False  # Don't raise exception on non-zero exit code
        )
        
        # Log the output
        logger.info(f"Penetration test exit code: {result.returncode}")
        
        if result.stdout:
            logger.info("Penetration test stdout:")
            for line in result.stdout.splitlines():
                logger.info(f"  {line}")
        
        if result.stderr:
            logger.warning("Penetration test stderr:")
            for line in result.stderr.splitlines():
                logger.warning(f"  {line}")
        
        # Check if report file was created
        if os.path.exists(report_file):
            logger.info(f"Penetration test report generated: {report_file}")
            return report_file
        else:
            logger.error(f"Penetration test report not found: {report_file}")
            return None
    except Exception as e:
        logger.error(f"Error running penetration tests: {str(e)}", exc_info=True)
        return None


def generate_html_report(json_report_path, output_dir):
    """Generate an HTML report from the JSON report."""
    if not os.path.exists(json_report_path):
        logger.error(f"JSON report not found: {json_report_path}")
        return None
    
    # Create HTML report filename
    html_report_path = json_report_path.replace('.json', '.html')
    
    try:
        # Load the JSON report
        with open(json_report_path, 'r') as f:
            report_data = json.load(f)
        
        # Generate HTML content
        html_content = generate_html_content(report_data)
        
        # Write HTML report
        with open(html_report_path, 'w') as f:
            f.write(html_content)
        
        logger.info(f"HTML report generated: {html_report_path}")
        return html_report_path
    except Exception as e:
        logger.error(f"Error generating HTML report: {str(e)}", exc_info=True)
        return None


def generate_html_content(report_data):
    """Generate HTML content from the report data."""
    # Extract summary data
    timestamp = report_data.get('timestamp', 'Unknown')
    base_url = report_data.get('base_url', 'Unknown')
    summary = report_data.get('summary', {})
    tests = report_data.get('tests', {})
    
    # Format timestamp
    try:
        dt = datetime.fromisoformat(timestamp)
        formatted_timestamp = dt.strftime('%Y-%m-%d %H:%M:%S')
    except:
        formatted_timestamp = timestamp
    
    # Generate HTML
    html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryoProtect v2 Security Penetration Test Report</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }}
        h1, h2, h3, h4 {{
            color: #2c3e50;
        }}
        .header {{
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }}
        .summary {{
            background-color: #f8f9fa;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
        }}
        .summary-status {{
            font-size: 1.2em;
            font-weight: bold;
        }}
        .passed {{
            color: #27ae60;
        }}
        .partial {{
            color: #f39c12;
        }}
        .failed {{
            color: #e74c3c;
        }}
        .category {{
            margin-bottom: 30px;
        }}
        .test {{
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
        }}
        .test-header {{
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }}
        .test-name {{
            font-weight: bold;
            font-size: 1.1em;
        }}
        .test-result {{
            font-weight: bold;
            padding: 3px 8px;
            border-radius: 3px;
            color: white;
        }}
        .test-result.passed {{
            background-color: #27ae60;
        }}
        .test-result.failed {{
            background-color: #e74c3c;
        }}
        .test-details {{
            background-color: #f8f9fa;
            border-radius: 3px;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            white-space: pre-wrap;
        }}
        .severity {{
            font-size: 0.9em;
            color: #7f8c8d;
        }}
        .severity.high {{
            color: #e74c3c;
        }}
        .severity.medium {{
            color: #f39c12;
        }}
        .severity.low {{
            color: #3498db;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }}
        th, td {{
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }}
        th {{
            background-color: #f2f2f2;
        }}
        tr:nth-child(even) {{
            background-color: #f9f9f9;
        }}
    </style>
</head>
<body>
    <div class="header">
        <h1>CryoProtect v2 Security Penetration Test Report</h1>
        <p>Generated: {formatted_timestamp}</p>
        <p>Target: {base_url}</p>
    </div>
    
    <div class="summary">
        <h2>Summary</h2>
        <p class="summary-status {summary.get('status', '').lower()}">
            Overall Status: {summary.get('status', 'Unknown')}
        </p>
        <p>Pass Rate: {summary.get('pass_rate', '0%')}</p>
        <p>Tests Passed: {summary.get('passed', 0)} / {summary.get('total', 0)}</p>
        <p>Tests Failed: {summary.get('failed', 0)}</p>
    </div>
    
    <h2>Test Results by Category</h2>
"""
    
    # Add test results by category
    for category, category_tests in tests.items():
        html += f"""
    <div class="category">
        <h3>{category}</h3>
"""
        
        for test_name, test_data in category_tests.items():
            passed = test_data.get('passed', False)
            result_class = "passed" if passed else "failed"
            result_text = "PASSED" if passed else "FAILED"
            severity = test_data.get('severity', 'medium')
            details = test_data.get('details', {})
            
            html += f"""
        <div class="test">
            <div class="test-header">
                <span class="test-name">{test_name}</span>
                <span class="test-result {result_class}">{result_text}</span>
            </div>
            <div class="severity {severity}">Severity: {severity.upper()}</div>
"""
            
            if details:
                html += f"""
            <div class="test-details">
{json.dumps(details, indent=2)}
            </div>
"""
            
            html += """
        </div>
"""
        
        html += """
    </div>
"""
    
    # Add recommendations section
    html += """
    <h2>Recommendations</h2>
    <table>
        <tr>
            <th>Category</th>
            <th>Test</th>
            <th>Status</th>
            <th>Recommendation</th>
        </tr>
"""
    
    # Generate recommendations for failed tests
    for category, category_tests in tests.items():
        for test_name, test_data in category_tests.items():
            if not test_data.get('passed', True):
                severity = test_data.get('severity', 'medium')
                details = test_data.get('details', {})
                
                # Generate recommendation based on test name and category
                recommendation = generate_recommendation(category, test_name, details)
                
                html += f"""
        <tr>
            <td>{category}</td>
            <td>{test_name}</td>
            <td class="failed">FAILED</td>
            <td>{recommendation}</td>
        </tr>
"""
    
    html += """
    </table>
    
    <div class="footer">
        <p>This report was generated automatically as part of the security validation process.</p>
        <p>For questions or assistance, please contact the security team.</p>
    </div>
</body>
</html>
"""
    
    return html


def generate_recommendation(category, test_name, details):
    """Generate a recommendation based on the failed test."""
    recommendations = {
        "CSRF Protection": {
            "csrf_token_endpoint": "Implement a CSRF token endpoint that returns a valid CSRF token for client-side applications.",
            "csrf_protection_enforced": "Ensure all state-changing endpoints (POST, PUT, PATCH, DELETE) validate CSRF tokens.",
            "valid_csrf_accepted": "Fix CSRF validation to properly accept valid CSRF tokens."
        },
        "Security Headers": {
            "security_headers_present": "Implement all required security headers in the application responses.",
            "content_security_policy_quality": "Improve Content Security Policy by avoiding 'unsafe-inline' for scripts."
        },
        "Cookie Security": {
            "secure_cookies": "Configure cookies with Secure, HttpOnly, and SameSite attributes.",
            "session_rotation": "Implement session rotation on security-sensitive events like privilege changes."
        },
        "Encryption at Rest": {
            "encryption_decryption": "Fix encryption/decryption implementation to correctly handle sensitive data.",
            "encryption_at_rest": "Implement proper encryption at rest for all sensitive data fields."
        },
        "Vulnerability Scanning": {
            "vulnerability_scan_scripts": "Ensure all vulnerability scanning scripts are present and executable.",
            "vulnerability_scan_execution": "Fix vulnerability scanning script execution issues."
        }
    }
    
    # Get default recommendation
    default_recommendation = "Review and fix the implementation according to security best practices."
    
    # Get category-specific recommendations
    category_recommendations = recommendations.get(category, {})
    
    # Get test-specific recommendation
    recommendation = category_recommendations.get(test_name, default_recommendation)
    
    # Add details-specific recommendations if available
    if category == "Security Headers" and test_name == "security_headers_present":
        missing_headers = details.get("missing_headers", [])
        if missing_headers:
            recommendation += f" Missing headers: {', '.join(missing_headers)}."
    
    return recommendation


def generate_pdf_report(html_report_path, output_dir):
    """Generate a PDF report from the HTML report."""
    if not os.path.exists(html_report_path):
        logger.error(f"HTML report not found: {html_report_path}")
        return None
    
    # Create PDF report filename
    pdf_report_path = html_report_path.replace('.html', '.pdf')
    
    try:
        # Check if wkhtmltopdf is installed
        wkhtmltopdf_path = shutil.which('wkhtmltopdf')
        if not wkhtmltopdf_path:
            logger.warning("wkhtmltopdf not found. PDF report generation skipped.")
            logger.warning("To generate PDF reports, install wkhtmltopdf: https://wkhtmltopdf.org/")
            return None
        
        # Generate PDF using wkhtmltopdf
        result = subprocess.run(
            [
                wkhtmltopdf_path,
                html_report_path,
                pdf_report_path
            ],
            capture_output=True,
            text=True,
            check=False
        )
        
        if result.returncode != 0:
            logger.error(f"Error generating PDF report: {result.stderr}")
            return None
        
        logger.info(f"PDF report generated: {pdf_report_path}")
        return pdf_report_path
    except Exception as e:
        logger.error(f"Error generating PDF report: {str(e)}", exc_info=True)
        return None


def create_summary_report(json_report_path, output_dir):
    """Create a summary report with key findings and recommendations."""
    if not os.path.exists(json_report_path):
        logger.error(f"JSON report not found: {json_report_path}")
        return None
    
    # Create summary report filename
    summary_report_path = os.path.join(output_dir, "pentest_summary.md")
    
    try:
        # Load the JSON report
        with open(json_report_path, 'r') as f:
            report_data = json.load(f)
        
        # Extract data
        timestamp = report_data.get('timestamp', 'Unknown')
        base_url = report_data.get('base_url', 'Unknown')
        summary = report_data.get('summary', {})
        tests = report_data.get('tests', {})
        
        # Format timestamp
        try:
            dt = datetime.fromisoformat(timestamp)
            formatted_timestamp = dt.strftime('%Y-%m-%d %H:%M:%S')
        except:
            formatted_timestamp = timestamp
        
        # Generate summary content
        content = f"""# CryoProtect v2 Security Penetration Test Summary

## Overview

- **Date:** {formatted_timestamp}
- **Target:** {base_url}
- **Status:** {summary.get('status', 'Unknown')}
- **Pass Rate:** {summary.get('pass_rate', '0%')}
- **Tests Passed:** {summary.get('passed', 0)} / {summary.get('total', 0)}
- **Tests Failed:** {summary.get('failed', 0)}

## Key Findings

"""
        
        # Add failed tests by severity
        failed_tests = []
        for category, category_tests in tests.items():
            for test_name, test_data in category_tests.items():
                if not test_data.get('passed', True):
                    failed_tests.append({
                        'category': category,
                        'test_name': test_name,
                        'severity': test_data.get('severity', 'medium'),
                        'details': test_data.get('details', {})
                    })
        
        # Sort by severity (high, medium, low)
        severity_order = {'high': 0, 'medium': 1, 'low': 2}
        failed_tests.sort(key=lambda x: severity_order.get(x['severity'], 99))
        
        if failed_tests:
            for test in failed_tests:
                content += f"### {test['category']}: {test['test_name']} (Severity: {test['severity'].upper()})\n\n"
                
                # Generate recommendation
                recommendation = generate_recommendation(test['category'], test['test_name'], test['details'])
                content += f"**Recommendation:** {recommendation}\n\n"
                
                # Add details if available
                if test['details']:
                    content += "**Details:**\n```json\n"
                    content += json.dumps(test['details'], indent=2)
                    content += "\n```\n\n"
        else:
            content += "No failed tests. All security controls are properly implemented.\n\n"
        
        # Add overall recommendations
        content += """## Overall Recommendations

"""
        
        if summary.get('status') == "PASSED":
            content += """All security controls have been properly implemented according to the remediation plan. Continue to:

1. Regularly run security scans to identify new vulnerabilities
2. Keep dependencies updated to address security patches
3. Conduct periodic manual penetration testing
4. Monitor security logs for suspicious activity
"""
        elif summary.get('status') == "PARTIAL":
            content += """Some security controls need improvement. Priority actions:

1. Address all high-severity findings immediately
2. Schedule fixes for medium-severity issues
3. Implement a regular security testing schedule
4. Review security logging and monitoring
"""
        else:
            content += """Critical security controls are missing or not properly implemented. Immediate actions required:

1. Address all failed tests, starting with high-severity issues
2. Implement proper security headers, CSRF protection, and cookie security
3. Verify encryption at rest for all sensitive data
4. Integrate vulnerability scanning into CI/CD pipeline
5. Re-test after implementing fixes
"""
        
        # Write summary report
        with open(summary_report_path, 'w') as f:
            f.write(content)
        
        logger.info(f"Summary report generated: {summary_report_path}")
        return summary_report_path
    except Exception as e:
        logger.error(f"Error creating summary report: {str(e)}", exc_info=True)
        return None


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="Security penetration test runner")
    parser.add_argument("--url", default=DEFAULT_URL, help=f"Base URL of the application to test (default: {DEFAULT_URL})")
    parser.add_argument("--output-dir", default=DEFAULT_OUTPUT_DIR, help=f"Directory to save reports (default: {DEFAULT_OUTPUT_DIR})")
    parser.add_argument("--html", action="store_true", help="Generate HTML report in addition to JSON")
    parser.add_argument("--pdf", action="store_true", help="Generate PDF report in addition to JSON")
    return parser.parse_args()


def main():
    """Main function."""
    args = parse_args()
    
    # Setup output directory
    setup_output_directory(args.output_dir)
    
    # Run penetration tests
    json_report_path = run_penetration_tests(args.url, args.output_dir)
    
    if not json_report_path:
        logger.error("Penetration testing failed to generate a report.")
        sys.exit(1)
    
    # Create summary report
    summary_report_path = create_summary_report(json_report_path, args.output_dir)
    
    # Generate HTML report if requested
    html_report_path = None
    if args.html:
        html_report_path = generate_html_report(json_report_path, args.output_dir)
    
    # Generate PDF report if requested
    if args.pdf and html_report_path:
        generate_pdf_report(html_report_path, args.output_dir)
    
    # Load the JSON report to determine exit code
    try:
        with open(json_report_path, 'r') as f:
            report_data = json.load(f)
        
        status = report_data.get('summary', {}).get('status')
        
        logger.info(f"Penetration testing completed with status: {status}")
        
        if status == "PASSED":
            logger.info("All security controls validated successfully.")
            sys.exit(0)
        else:
            logger.warning("Some security controls failed validation. See report for details.")
            sys.exit(1)
    except Exception as e:
        logger.error(f"Error reading report: {str(e)}", exc_info=True)
        sys.exit(1)


if __name__ == "__main__":
    main()